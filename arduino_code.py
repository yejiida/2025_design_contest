# -*- coding: utf-8 -*-
"""Arduino_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OLtIGGBJptUUZiBIn3wgtE_kHF9oYpYp
"""

#define PIN_TB_PWM   25
#define PIN_TB_AIN1  26
#define PIN_TB_AIN2  33
#define PIN_TB_STBY  27

#define PIN_ESC_L    18
#define PIN_ESC_R    19
#define PIN_SERVO    21

const int CH_TB     = 0;
const int CH_ESC_L  = 1;
const int CH_ESC_R  = 2;
const int CH_SERVO  = 3;

const int FREQ_TB   = 20000;   // 20 kHz (TB6612)
const int RES_TB    = 12;

const int FREQ_SRV  = 50;      // 50 Hz (ESC/서보 표준)
const int RES_SRV   = 16;

const int PULSE_MIN_US = 1000;
const int PULSE_MID_US = 1500;
const int PULSE_MAX_US = 2000;

#define UART_RX   16
#define UART_TX   17
HardwareSerial Serial2(2);

uint32_t lastCmdMs = 0;
const uint32_t CMD_TIMEOUT_MS = 500;
float throttle = 0.0f;   // -1.0 ~ +1.0
float steer    = 0.0f;   // -1.0 ~ +1.0
int   servo_us  = PULSE_MID_US;
uint8_t shaftSp = 0;

uint32_t usToDuty(int us, int freq, int resBits) {
  const float period_us = 1000000.0f / float(freq);
  float ratio = float(us) / period_us;
  uint32_t maxCount = (1UL << resBits) - 1;
  uint32_t duty = uint32_t(ratio * maxCount);
  return (duty > maxCount) ? maxCount : duty;
}
void writePulseUS(int channel, int us) {
  us = constrain(us, PULSE_MIN_US, PULSE_MAX_US);
  ledcWrite(channel, usToDuty(us, FREQ_SRV, RES_SRV));
}
void shaftDir(bool forward) {
  digitalWrite(PIN_TB_AIN1, forward ? HIGH : LOW);
  digitalWrite(PIN_TB_AIN2, forward ? LOW  : HIGH);
}
void writeShaftSpeed(uint8_t speed255) {
  uint32_t duty = map(speed255, 0, 255, 0, (1<<RES_TB)-1);
  ledcWrite(CH_TB, duty);
}
float ramp(float curr, float target, float step){
  if (target > curr) curr = min(target, curr + step);
  else
curr = max(target, curr - step);
  return curr;
}
void setup() {
  // TB6612 IO
  pinMode(PIN_TB_AIN1, OUTPUT);
  pinMode(PIN_TB_AIN2, OUTPUT);
  pinMode(PIN_TB_STBY, OUTPUT);
  digitalWrite(PIN_TB_STBY, HIGH);

  // PWM 채널 세팅
  ledcSetup(CH_TB,    FREQ_TB,  RES_TB);
  ledcAttachPin(PIN_TB_PWM, CH_TB);

  ledcSetup(CH_ESC_L, FREQ_SRV, RES_SRV);
  ledcSetup(CH_ESC_R, FREQ_SRV, RES_SRV);
  ledcSetup(CH_SERVO, FREQ_SRV, RES_SRV);

  ledcAttachPin(PIN_ESC_L, CH_ESC_L);
  ledcAttachPin(PIN_ESC_R, CH_ESC_R);
  ledcAttachPin(PIN_SERVO, CH_SERVO);

  // UART
  Serial.begin(115200);
  Serial2.begin(115200, SERIAL_8N1, UART_RX, UART_TX);

  // 초기 안전 상태
  safeStop();
  delay(2000); // ESC 아밍 대기

  Serial.println("ESP32 READY");
}
void parseLine(const String& line){
  int idx;

  idx = line.indexOf("T:");
  if (idx >= 0){
    float t = line.substring(idx+2).toFloat();
    throttle = constrain(t, -1.0f, 1.0f);
  }
  idx = line.indexOf("S:");
  if (idx >= 0){
    float s = line.substring(idx+2).toFloat();
    steer = constrain(s, -1.0f, 1.0f);
  }
  idx = line.indexOf("SV:");
  if (idx >= 0){
    int sv = line.substring(idx+3).toInt();
    servo_us = constrain(sv, PULSE_MIN_US, PULSE_MAX_US);
    writePulseUS(CH_SERVO, servo_us);
  }
  idx = line.indexOf("SH:");
  if (idx >= 0){
    int sh = line.substring(idx+3).toInt();
    shaftSp = (uint8_t) constrain(sh, 0, 255);
    shaftDir(true);
    writeShaftSpeed(shaftSp);
  }
  // CL 처리 가능
  lastCmdMs = millis();
}
int mixToPulse(float v){
  v = constrain(v, -1.0f, 1.0f);
  if (ESC_BIDIRECTIONAL) {
    return map((int)(v*1000), -1000, 1000, PULSE_MIN_US, PULSE_MAX_US);
  } else {
    float fwd = max(0.0f, v);
    return map((int)(fwd*1000), 0, 1000, PULSE_MIN_US, PULSE_MAX_US);
  }
}
void applyDrive(){
  float left  = throttle - steer;
  float right = throttle + steer;

  static float l=0, r=0;
  l = ramp(l, left, 0.05f);
  r = ramp(r, right,0.05f);

  int pulL = mixToPulse(l);
  int pulR = mixToPulse(r);

  writePulseUS(CH_ESC_L, pulL);
  writePulseUS(CH_ESC_R, pulR);
}
void safeStop(){
  if (ESC_BIDIRECTIONAL) {
    writePulseUS(CH_ESC_L, PULSE_MID_US);
    writePulseUS(CH_ESC_R, PULSE_MID_US);
  } else {
    writePulseUS(CH_ESC_L, PULSE_MIN_US);
    writePulseUS(CH_ESC_R, PULSE_MIN_US);
  }
  writeShaftSpeed(0);
  writePulseUS(CH_SERVO, PULSE_MID_US);
}
void loop() {
  // 1) 명령 수신
  while (Serial2.available()){
    String line = Serial2.readStringUntil('\n');
    line.trim();
    if (line.length() > 0){
      parseLine(line);
      Serial.print("RX: "); Serial.println(line);
    }
  }
  // 2) 타임아웃 → 안전 정지
  if (millis() - lastCmdMs > CMD_TIMEOUT_MS){
    safeStop();
  } else {
    applyDrive();
  }
  delay(10);
}