# -*- coding: utf-8 -*-
"""riverbot_stream.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1geJCPYtkAVjJpjB7hi-O2tuK68yZMIW3
"""

# -*- coding: utf-8 -*-
"""
RiverBot: YOLO control + MJPEG web streaming (Raspberry Pi)
- YOLO v8n으로 프레임 추론
- ESP32(시리얼)로 T,S,SV,SH 명령 전송
- Flask로 주석된 프레임을 /video_feed 로 스트리밍(MJPEG)
- 노트북에서 http://<pi_ip>:5000 접속
"""

import argparse
import threading
import time
import signal
import sys

import cv2
import serial
from ultralytics import YOLO
from flask import Flask, Response, render_template_string

# -------------------- 기본 파라미터 --------------------
# 3개 클래스(예: 0=플라스틱, 1=금속, 2=스티로폼)만 사용
VALID_CLASSES = {0, 1, 2}

# 분류 서보 위치(슬롯 위치에 맞게 현장 튜닝)
CLASS_TO_SERVO_US = {
    0: 1150,  # 슬롯1
    1: 1500,  # 슬롯2
    2: 1850,  # 슬롯3
}

# 제어 파라미터
CONF_THRES       = 0.5
KP_STEER         = 0.8       # 중심 오차 → 조향 비례계수
BASE_THROTTLE    = 0.35      # 기본 전진 (0~1)
THROTTLE_NEAR    = 0.18      # 근접 시 감속
THROTTLE_STOP    = 0.0       # 정지
W_STOP           = 200       # bbox 너비 임계(픽셀): 근접 판정
SHAFT_SPEED_COLLECT = 180    # 수거 ON
SHAFT_SPEED_IDLE    = 0      # 평시 OFF

# 탐색 동작(탐지 실패 시)
SEARCH_STEER   = 0.30
SEARCH_PERIOD  = 2.0   # s, 좌↔우 전환 주기

# JPEG 인코딩 품질/프레임레이트
JPEG_QUALITY = 70
STREAM_SLEEP = 0.03    # 초당 ~33프레임 정도(여건에 맞게 0.03~0.06 조절)

# -------------------- 전역 상태 --------------------
app = Flask(__name__)
latest_jpeg = None
latest_lock = threading.Lock()
running = True

# 텔레메트리(옵션)
telemetry = {
    "fps": 0.0,
    "last_cls": None,
    "last_cmd": "",
}

# -------------------- 시리얼 유틸 --------------------
def open_serial(port, baud):
    ser = serial.Serial(port, baudrate=baud, timeout=0.01)
    time.sleep(2.0)  # ESP32 리셋/아밍 대기
    return ser

def send_cmd(ser, T=None, S=None, CL=None, SV=None, SH=None):
    parts = []
    if T is not None:  parts.append(f"T:{T:.3f}")
    if S is not None:  parts.append(f"S:{S:.3f}")
    if CL is not None: parts.append(f"CL:{int(CL)}")
    if SV is not None: parts.append(f"SV:{int(SV)}")
    if SH is not None: parts.append(f"SH:{int(SH)}")
    if not parts:
        return
    line = ",".join(parts) + "\n"
    ser.write(line.encode("ascii"))
    telemetry["last_cmd"] = line.strip()

# -------------------- 스트리밍 HTTP --------------------
INDEX_HTML = """
<!doctype html>
<title>RiverBot Live</title>
<style>
  body { margin:0; background:#111; color:#eee; font-family:system-ui, sans-serif; }
  header { padding:12px 16px; background:#1e1e1e; position:sticky; top:0; }
  main { display:flex; gap:16px; padding:16px; flex-wrap:wrap; align-items:flex-start; }
  .card { background:#1a1a1a; border-radius:12px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.3);}
  img { max-width:100%; height:auto; border-radius:8px; display:block; }
  .meta { font-size:14px; opacity:.85; line-height:1.6; }
  .badge { background:#2a2a2a; border-radius:8px; padding:4px 8px; margin-right:6px; }
</style>
<header>
  <h2>RiverBot — Live Stream</h2>
</header>
<main>
  <div class="card">
    <img src="/video_feed" alt="live">
  </div>
  <div class="card meta">
    <div><span class="badge">FPS</span><span id="fps">–</span></div>
    <div><span class="badge">Last Class</span><span id="cls">–</span></div>
    <div><span class="badge">Last Cmd</span><code id="cmd">–</code></div>
  </div>
</main>
<script>
async function poll(){
  try{
    const r = await fetch('/stats'); const j = await r.json();
    document.getElementById('fps').textContent = j.fps.toFixed(1);
    document.getElementById('cls').textContent = (j.last_cls === null ? 'None' : j.last_cls);
    document.getElementById('cmd').textContent = j.last_cmd;
  }catch(e){}
  setTimeout(poll, 500);
}
poll();
</script>
"""

@app.route("/")
def index():
    return render_template_string(INDEX_HTML)

@app.route("/stats")
def stats():
    return telemetry

@app.route("/video_feed")
def video_feed():
    def gen():
        while running:
            with latest_lock:
                jpg = latest_jpeg
            if jpg is not None:
                yield (b"--frame\r\nContent-Type: image/jpeg\r\n"
                       b"Content-Length: " + str(len(jpg)).encode() + b"\r\n\r\n" +
                       jpg + b"\r\n")
            time.sleep(STREAM_SLEEP)
    return Response(gen(), mimetype="multipart/x-mixed-replace; boundary=frame")

# -------------------- 추론/제어 스레드 --------------------
def yolo_control_loop(args):
    global latest_jpeg, running
    # 장치 준비
    model = YOLO(args.model)
    ser = open_serial(args.port, args.baud)
    cap = cv2.VideoCapture(args.cam)  # USB 웹캠 기준
    if not cap.isOpened():
        print("[ERR] Camera open failed. Change --cam index.")
        running = False
        return

    last_search_toggle = time.time()
    search_dir = 1
    t_prev = time.time()
    fps_ma = None

    try:
        while running:
            ok, frame = cap.read()
            if not ok:
                send_cmd(ser, T=0.0, S=0.0, SV=1500, SH=0)
                time.sleep(0.05)
                continue

            h, w = frame.shape[:2]
            cx_frame = w/2.0

            # YOLO 추론 (conf 필터)
            res = model.predict(source=frame, verbose=False, conf=CONF_THRES)

            # 타깃 선택(가장 중심에 가까운 bbox, 유효 클래스만)
            target = None
            for r in res:
                for b in r.boxes:
                    cls = int(b.cls.item())
                    if cls not in VALID_CLASSES:
                        continue
                    x1, y1, x2, y2 = map(float, b.xyxy[0].tolist())
                    bx = (x1 + x2) / 2.0
                    bw = (x2 - x1)
                    cand = {"cls": cls, "cx": bx, "w": bw, "box": (x1,y1,x2,y2)}
                    if (target is None or abs(cand["cx"] - cx_frame) < abs(target["cx"] - cx_frame)):
                        target = cand

            # 제어 + 주석
            annotated = frame
            if target is not None:
                err = (target["cx"] - cx_frame) / (w/2.0)   # -1..+1
                steer = max(-1.0, min(1.0, KP_STEER * err))

                if target["w"] >= W_STOP:
                    throttle = THROTTLE_STOP
                    cls = target["cls"]
                    servo_us = CLASS_TO_SERVO_US.get(cls, 1500)
                    send_cmd(ser, T=throttle, S=0.0, CL=cls, SV=servo_us, SH=SHAFT_SPEED_COLLECT)
                    telemetry["last_cls"] = cls
                else:
                    throttle = THROTTLE_NEAR if target["w"] > (0.6*W_STOP) else BASE_THROTTLE
                    send_cmd(ser, T=throttle, S=steer, SV=1500, SH=SHAFT_SPEED_IDLE)

                # 주석(박스/중심선)
                x1, y1, x2, y2 = map(int, target["box"])
                cv2.rectangle(annotated,(x1,y1),(x2,y2),(0,255,0),2)
                cv2.line(annotated,(int(cx_frame),0),(int(cx_frame),h),(255,255,255),1)
                cv2.putText(annotated,f"cls:{target['cls']} w:{int(target['w'])}",
                            (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.8,(0,255,0),2)
            else:
                # 탐지 실패: 좌↔우 탐색(또는 저속 전진)
                now = time.time()
                if now - last_search_toggle > SEARCH_PERIOD:
                    search_dir *= -1
                    last_search_toggle = now
                steer = SEARCH_STEER * search_dir
                send_cmd(ser, T=0.12, S=steer, SV=1500, SH=0)

            # FPS 계산(지수가중 이동평균)
            t_now = time.time()
            dt = t_now - t_prev
            t_prev = t_now
            inst_fps = 1.0 / dt if dt > 0 else 0.0
            fps_ma = inst_fps if fps_ma is None else (0.9*fps_ma + 0.1*inst_fps)
            telemetry["fps"] = fps_ma

            # OSD
            cv2.putText(annotated, f"FPS:{fps_ma:4.1f}", (10, h-12),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (200,200,0), 2)

            # JPEG 인코딩 → 최신 프레임 캐시
            ok_jpg, buf = cv2.imencode(".jpg", annotated, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
            if ok_jpg:
                with latest_lock:
                    globals()["latest_jpeg"] = buf.tobytes()

    finally:
        try:
            send_cmd(ser, T=0.0, S=0.0, SV=1500, SH=0)
            time.sleep(0.1)
        except Exception:
            pass
        cap.release()
        ser.close()

# -------------------- 메인 --------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--port", default="/dev/ttyUSB0")
    parser.add_argument("--baud", type=int, default=115200)
    parser.add_argument("--cam", type=int, default=0)
    parser.add_argument("--model", default="best.pt")
    parser.add_argument("--host", default="0.0.0.0")   # 외부 접속 허용
    parser.add_argument("--web-port", type=int, default=5000)
    args = parser.parse_args()

    # 종료 신호 처리
    def handle_sig(sig, frame):
        global running
        running = False
    signal.signal(signal.SIGINT, handle_sig)
    signal.signal(signal.SIGTERM, handle_sig)

    # YOLO+제어 스레드 시작
    t = threading.Thread(target=yolo_control_loop, args=(args,), daemon=True)
    t.start()

    # Flask 웹 서버 실행 (메인 스레드)
    app.run(host=args.host, port=args.web_port, threaded=True)

    # 서버 종료되면 루프도 종료
    globals()["running"] = False
    t.join(timeout=2.0)
    return 0

if __name__ == "__main__":
    sys.exit(main())